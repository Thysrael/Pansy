## 架构分析

### 匹配的优先级

​	比如说对于字符串 `<=` 。正则表达式 `"<"` 和 `"<="` 都可以匹配上，所以匹配的时候要注意优先级问题，其实只有两点，就是

- 长串优先匹配。这是对应上面描述的情况
- 保留字优先匹配。这是对应 `main1` 和 `main` 都可以匹配的情况。



## 正则表达式

### 转义与正则

我们首先看一段关于转义字符的解释：

> 转义序列通常有两种功能。第一个是编码一个句法上的实体，如设备命令或者无法被字母表直接表示的特殊数据。第二种功能，也叫字符引用，用于表示无法在当前上下文中被键盘录入的字符（如字符串中的回车符），或者在当前上下文中会有不期望的含义的字符（如C语言字符串中的双引号字符"，不能直接出现，必须用转义序列表示）。在后面那种情况，转义序列是一种由转义字符自身和一个被引用的字符组成的一个二合字母（digraph）情形。

我觉得关键点在于两处，即：

- 一个特殊的实体，没法表示的原因：
  - 不好直接表示，比如换行符，总不能打 `enter` 吧
  - 有多重语义，比如对于字符串分界符 `"` ，如果想打印他，就必须 `\"` ，同样的，对于 `\` ，想打印就必须 `\\`
- 二合字母，为了表示他们，我们需要用两个字符来表示，一般第一个字符是 `/`。

如果我们说希望一个字符串是具有转义功能的，那么就是希望它有这种功能 `\n -> enter`。

当我们用 `Java` 写正则表达式的时候，因为正则本身就具有一些转义字符（比 C 要多一些），比如 `\s` 表示空白符，`\w` 表示字母。我们去写的时候，经常出现 `\\n, \\s, \\d` 这种结构，就很让人费解，这个其实可以分成两步理解，以 `\\n` 为例

- 字符串 `\\n` 被处理成了正则表达式 `\n` 。
- 正则表达式 `\n` 对应了“换行” 。

### 贪婪匹配

正则表达式是默认贪婪匹配的，也就是说 `+, *` 这种符号都是有多少就匹配多少，如果想要让其非贪婪，需要将其替换成 `+?, *?`。 

在编译器中，字符串，多行注释都是需要进行非贪婪匹配的。

### 注释的正则表达

这个 `.` 匹配的是**“匹配除换行符（\n、\r）之外的任何单个字符”**。所以可以用来匹配单行注释而且不发生错误。即

```java
String SINGLE_COMMENT_REGEX = "//.*"
```

对于多行注释，为了可以实现换行功能，我们需要声明是可以匹配换行的

```java
String MULTI_COMMENT_REGEX = "/\*(.|\n|\r)*?\*/"
```

### 空白符

`/s` 可以很好的匹配所有空白字符，等价于 `[ \f\n\r\t\v]` 所以我们可以利用他完成换行功能。

### 保留字

对于保留字，易错点是容易将其与**标识符**弄混，可以通过“先匹配保留字，如果匹配不成功，再匹配标识符“的方式解决。

但是这样并不能完全解决问题，因为对于 `main0` 这样的标识符，如果先匹配，似乎会被识别，所以稳妥一点的方法是加入后缀，避免出问题

```java
"(?![a-zA-Z0-9_])"
```

