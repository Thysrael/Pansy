## 伪指令

- 可以使用普通指令和**伪指令**（也就是 `la` 这样的指令是可以使用的）因为 MARS 一定会将伪指令翻译成普通指令，所以似乎可以节省一部分的后端翻译工作。
- 伪指令的好处在于真的很方便，不需要了解很多的指令细节，就可以很方便的构造各种指令，唯一的缺点是可以能利用 `$at` 寄存器，这就导致了指令到底涉及几个寄存器不太清楚。
- 不过无论怎样，可以肯定，在计组中学的汇编知识，绝对不够搭建一个高效的 `CodeGen` 系统。
- 个人感觉还是应当以尽量少的利用伪指令为思路，因为伪指令具体翻译成啥样子，确实不清楚。



## Directives

- `.data` 用于声明数据段。但是 MARS 中似乎并不配备 `bss` 段的能力。
- `.asciiz` 会声明一个带终结符的字符串空间，而 `.ascii` 没有终结符，应当采用，因为在 llvm ir 中就已经有了结尾符。
- 但是对于终结符， MARS 可以识别 `\00` 。
- MARS 不能识别 `\0a` ，但是能识别 `\n`。看来又需要写一个方法来进行转换了。
- 尽管没有 bss 段，但是有 `.space` 伪指令，可以用于全零初始化，但是我感觉没有啥用
- `la` 伪指令好东西，可以不利用 `a1` 达到加载标签地址的目的，可以考虑记忆地址的的方法，这样在加载的时候，`data` 从 `0x10010000` 开始加载，可以用一个 `lui` 把高位地址加载入寄存器，再利用 `lw` 的 `offset` 去搞低位地址（但是如果 offset 过大，那么就没法优化了，所以要从两个方面入手，一个是尽量减少全局变量的数量（重点在于全局字符串）。另一个是可以先手动 `la`，然后再窥孔给他降下去，或者直接写，乐），但是如果直接写 `la` 的话，就没有这种效果了，考虑手动实现 `la`（所以最终还是要记忆各种东西）
- 



## MARS 特性

- MARS 中是允许十六进制的，写作 `0x1`。



## 指令特性

- 